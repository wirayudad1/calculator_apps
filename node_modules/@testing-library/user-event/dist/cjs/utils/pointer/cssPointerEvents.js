'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var options = require('../../options.js');
require('../click/isClickableInput.js');
require('../dataTransfer/Clipboard.js');
require('../../event/eventMap.js');
require('../../event/behavior/click.js');
require('../../event/behavior/cut.js');
require('../../event/behavior/keydown.js');
require('../../event/behavior/keypress.js');
require('../../event/behavior/keyup.js');
require('../../event/behavior/paste.js');
require('@testing-library/dom');
require('../edit/maxLength.js');
require('../edit/isEditable.js');
var isElementType = require('../misc/isElementType.js');
var getWindow = require('../misc/getWindow.js');
require('../keyDef/readNextDescriptor.js');
var level = require('../misc/level.js');

function hasPointerEvents(config, element) {
    return checkPointerEvents(config, element)?.pointerEvents !== 'none';
}
function closestPointerEventsDeclaration(element) {
    const window = getWindow.getWindow(element);
    for(let el = element, tree = []; el?.ownerDocument; el = el.parentElement){
        tree.push(el);
        const pointerEvents = window.getComputedStyle(el).pointerEvents;
        if (pointerEvents && ![
            'inherit',
            'unset'
        ].includes(pointerEvents)) {
            return {
                pointerEvents,
                tree
            };
        }
    }
    return undefined;
}
const PointerEventsCheck = Symbol('Last check for pointer-events');
function checkPointerEvents(config, element) {
    const lastCheck = element[PointerEventsCheck];
    const needsCheck = config.pointerEventsCheck !== options.PointerEventsCheckLevel.Never && (!lastCheck || hasBitFlag(config.pointerEventsCheck, options.PointerEventsCheckLevel.EachApiCall) && lastCheck[level.ApiLevel.Call] !== level.getLevelRef(config, level.ApiLevel.Call) || hasBitFlag(config.pointerEventsCheck, options.PointerEventsCheckLevel.EachTrigger) && lastCheck[level.ApiLevel.Trigger] !== level.getLevelRef(config, level.ApiLevel.Trigger));
    if (!needsCheck) {
        return lastCheck?.result;
    }
    const declaration = closestPointerEventsDeclaration(element);
    element[PointerEventsCheck] = {
        [level.ApiLevel.Call]: level.getLevelRef(config, level.ApiLevel.Call),
        [level.ApiLevel.Trigger]: level.getLevelRef(config, level.ApiLevel.Trigger),
        result: declaration
    };
    return declaration;
}
function assertPointerEvents(config, element) {
    const declaration = checkPointerEvents(config, element);
    if (declaration?.pointerEvents === 'none') {
        throw new Error([
            `Unable to perform pointer interaction as the element ${declaration.tree.length > 1 ? 'inherits' : 'has'} \`pointer-events: none\`:`,
            '',
            printTree(declaration.tree), 
        ].join('\n'));
    }
}
function printTree(tree) {
    return tree.reverse().map((el, i)=>[
            ''.padEnd(i),
            el.tagName,
            el.id && `#${el.id}`,
            el.hasAttribute('data-testid') && `(testId=${el.getAttribute('data-testid')})`,
            getLabelDescr(el),
            tree.length > 1 && i === 0 && '  <-- This element declared `pointer-events: none`',
            tree.length > 1 && i === tree.length - 1 && '  <-- Asserted pointer events here', 
        ].filter(Boolean).join('')).join('\n');
}
function getLabelDescr(element) {
    let label;
    if (element.hasAttribute('aria-label')) {
        label = element.getAttribute('aria-label');
    } else if (element.hasAttribute('aria-labelledby')) {
        label = element.ownerDocument.getElementById(element.getAttribute('aria-labelledby'))?.textContent?.trim();
    } else if (isElementType.isElementType(element, [
        'button',
        'input',
        'meter',
        'output',
        'progress',
        'select',
        'textarea', 
    ]) && element.labels?.length) {
        label = Array.from(element.labels).map((el)=>el.textContent?.trim()).join('|');
    } else if (isElementType.isElementType(element, 'button')) {
        label = element.textContent?.trim();
    }
    label = label?.replace(/\n/g, '  ');
    if (Number(label?.length) > 30) {
        label = `${label?.substring(0, 29)}â€¦`;
    }
    return label ? `(label=${label})` : '';
}
// With the eslint rule and prettier the bitwise operation isn't nice to read
function hasBitFlag(conf, flag) {
    // eslint-disable-next-line no-bitwise
    return (conf & flag) > 0;
}

exports.assertPointerEvents = assertPointerEvents;
exports.hasPointerEvents = hasPointerEvents;
