'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('../setup/index.js');
require('../utils/click/isClickableInput.js');
require('../utils/dataTransfer/Clipboard.js');
require('../event/eventMap.js');
require('../event/behavior/click.js');
require('../event/behavior/cut.js');
require('../event/behavior/keydown.js');
require('../event/behavior/keypress.js');
require('../event/behavior/keyup.js');
require('../event/behavior/paste.js');
require('@testing-library/dom');
require('../utils/edit/maxLength.js');
require('../utils/edit/isEditable.js');
require('@testing-library/dom/dist/helpers.js');
require('../utils/keyDef/readNextDescriptor.js');
var level = require('../utils/misc/level.js');
var wait = require('../utils/misc/wait.js');
require('../options.js');
var parseKeyDef = require('./parseKeyDef.js');
var config = require('../setup/config.js');

async function pointer(input) {
    const { pointerMap  } = this[config.Config];
    const actions = [];
    (Array.isArray(input) ? input : [
        input
    ]).forEach((actionInput)=>{
        if (typeof actionInput === 'string') {
            actions.push(...parseKeyDef.parseKeyDef(pointerMap, actionInput));
        } else if ('keys' in actionInput) {
            actions.push(...parseKeyDef.parseKeyDef(pointerMap, actionInput.keys).map((i)=>({
                    ...actionInput,
                    ...i
                })));
        } else {
            actions.push(actionInput);
        }
    });
    for(let i = 0; i < actions.length; i++){
        await wait.wait(this[config.Config]);
        await pointerAction(this[config.Config], actions[i]);
    }
    this[config.Config].system.pointer.resetClickCount();
}
async function pointerAction(config, action) {
    const pointerName = 'pointerName' in action && action.pointerName ? action.pointerName : 'keyDef' in action ? config.system.pointer.getPointerName(action.keyDef) : 'mouse';
    const previousPosition = config.system.pointer.getPreviousPosition(pointerName);
    const position = {
        target: action.target ?? getPrevTarget(config, previousPosition),
        coords: action.coords ?? previousPosition?.coords,
        caret: {
            node: action.node ?? (hasCaretPosition(action) ? undefined : previousPosition?.caret?.node),
            offset: action.offset ?? (hasCaretPosition(action) ? undefined : previousPosition?.caret?.offset)
        }
    };
    if ('keyDef' in action) {
        if (config.system.pointer.isKeyPressed(action.keyDef)) {
            level.setLevelRef(config, level.ApiLevel.Trigger);
            await config.system.pointer.release(config, action.keyDef, position);
        }
        if (!action.releasePrevious) {
            level.setLevelRef(config, level.ApiLevel.Trigger);
            await config.system.pointer.press(config, action.keyDef, position);
            if (action.releaseSelf) {
                level.setLevelRef(config, level.ApiLevel.Trigger);
                await config.system.pointer.release(config, action.keyDef, position);
            }
        }
    } else {
        level.setLevelRef(config, level.ApiLevel.Trigger);
        await config.system.pointer.move(config, pointerName, position);
    }
}
function hasCaretPosition(action) {
    return !!((action.target ?? action.node) ?? action.offset !== undefined);
}
function getPrevTarget(config, position) {
    if (!position) {
        throw new Error('This pointer has no previous position. Provide a target property!');
    }
    return position.target ?? config.document.body;
}

exports.pointer = pointer;
