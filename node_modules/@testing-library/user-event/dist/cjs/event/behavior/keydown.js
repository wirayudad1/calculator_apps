'use strict';

require('../../utils/click/isClickableInput.js');
require('../../utils/dataTransfer/Clipboard.js');
var getValue = require('../../utils/edit/getValue.js');
var input = require('../../utils/edit/input.js');
var isContentEditable = require('../../utils/edit/isContentEditable.js');
var isEditable = require('../../utils/edit/isEditable.js');
var walkRadio = require('../../utils/edit/walkRadio.js');
require('@testing-library/dom');
var isElementType = require('../../utils/misc/isElementType.js');
require('@testing-library/dom/dist/helpers.js');
var selection = require('../../utils/focus/selection.js');
var focus = require('../../utils/focus/focus.js');
var getTabDestination = require('../../utils/focus/getTabDestination.js');
var selectAll = require('../../utils/focus/selectAll.js');
require('../../utils/keyDef/readNextDescriptor.js');
require('../../utils/misc/level.js');
require('../../options.js');
require('../eventMap.js');
require('./click.js');
require('./cut.js');
require('./keypress.js');
require('./keyup.js');
require('./paste.js');
var registry = require('./registry.js');
var selection$1 = require('../../document/selection.js');

registry.behavior.keydown = (event, target, config)=>{
    return keydownBehavior[event.key]?.(event, target, config) ?? combinationBehavior(event, target, config);
};
const keydownBehavior = {
    ArrowDown: (event, target, config)=>{
        /* istanbul ignore else */ if (isElementType.isElementType(target, 'input', {
            type: 'radio'
        })) {
            return ()=>walkRadio.walkRadio(config, target, -1);
        }
    },
    ArrowLeft: (event, target, config)=>{
        if (isElementType.isElementType(target, 'input', {
            type: 'radio'
        })) {
            return ()=>walkRadio.walkRadio(config, target, -1);
        }
        return ()=>selection.moveSelection(target, -1);
    },
    ArrowRight: (event, target, config)=>{
        if (isElementType.isElementType(target, 'input', {
            type: 'radio'
        })) {
            return ()=>walkRadio.walkRadio(config, target, 1);
        }
        return ()=>selection.moveSelection(target, 1);
    },
    ArrowUp: (event, target, config)=>{
        /* istanbul ignore else */ if (isElementType.isElementType(target, 'input', {
            type: 'radio'
        })) {
            return ()=>walkRadio.walkRadio(config, target, 1);
        }
    },
    Backspace: (event, target, config)=>{
        if (isEditable.isEditable(target)) {
            return ()=>{
                input.input(config, target, '', 'deleteContentBackward');
            };
        }
    },
    Delete: (event, target, config)=>{
        if (isEditable.isEditable(target)) {
            return ()=>{
                input.input(config, target, '', 'deleteContentForward');
            };
        }
    },
    End: (event, target)=>{
        if (isElementType.isElementType(target, [
            'input',
            'textarea'
        ]) || isContentEditable.isContentEditable(target)) {
            return ()=>{
                const newPos = getValue.getValue(target)?.length ?? /* istanbul ignore next */ 0;
                selection.setSelectionRange(target, newPos, newPos);
            };
        }
    },
    Home: (event, target)=>{
        if (isElementType.isElementType(target, [
            'input',
            'textarea'
        ]) || isContentEditable.isContentEditable(target)) {
            return ()=>{
                selection.setSelectionRange(target, 0, 0);
            };
        }
    },
    PageDown: (event, target)=>{
        if (isElementType.isElementType(target, [
            'input'
        ])) {
            return ()=>{
                const newPos = getValue.getValue(target).length;
                selection.setSelectionRange(target, newPos, newPos);
            };
        }
    },
    PageUp: (event, target)=>{
        if (isElementType.isElementType(target, [
            'input'
        ])) {
            return ()=>{
                selection.setSelectionRange(target, 0, 0);
            };
        }
    },
    Tab: (event, target, config)=>{
        return ()=>{
            const dest = getTabDestination.getTabDestination(target, config.system.keyboard.modifiers.Shift);
            focus.focus(dest);
            if (selection.hasOwnSelection(dest)) {
                selection$1.setUISelection(dest, {
                    anchorOffset: 0,
                    focusOffset: dest.value.length
                });
            }
        };
    }
};
const combinationBehavior = (event, target, config)=>{
    if (event.code === 'KeyA' && config.system.keyboard.modifiers.Control) {
        return ()=>selectAll.selectAll(target);
    }
};
