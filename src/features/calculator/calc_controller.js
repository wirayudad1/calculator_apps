import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

let initialState = {
  value: 0,
  operation:'',
  result:0,
  current_oper:'',
  clicknumber:0,
  doing:0,
  cal_display:0,
  status: 'idle',
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export let operator =''
export let coma=null
export let lastInput=0
export const counterSlice = createSlice({
  name: 'count',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    operation(state,oper){
      console.log(state,oper)
      operator=oper.payload['operation']
      if(state.current_oper==''&&oper.payload['koma']==null){
        console.log('masukadaoper')
        state.cal_display+=oper.payload['operation']
        coma=oper.payload['koma']
        state.current_oper=oper.payload['operation']
      }
      if(oper.payload['koma']!=null){
        state.cal_display+=oper.payload['koma']
        coma=oper.payload['koma']
        state.current_oper=operator
      }
      
      state.result=parseFloat(state.value);
      console.log(state.result)
    },
    reset(state,oper){
      state.result=0
      state.value=0
      operator=''
      state.cal_display=0
      state.doing=0
      state.clicknumber=0
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    calculationByAmount: (state, action) => {
      console.log(action.payload['koma'])
      
      let info=action.payload;
      let data=[];
      state.current_oper=''
      console.log(info.operation,state.doing)
      if(state.doing==0){
        if(state.clicknumber==0)
        {
          console.log('clickonce')
          state.cal_display+=action.payload['number']
          state.result=state.cal_display
          state.clicknumber++
        }   
        else{
           console.log('clickmany')
            state.cal_display+=action.payload['number'].toString()
            state.result=state.cal_display
        }    
      }
      else
      {
        state.cal_display+=action.payload['number']
      }
      
      //state.cal_display+=action.payload['number']
      state.value=0
      let lastNumber=(state.cal_display.toString()).split(/[\s()x*/%+-]+/)
      //let lastNumber=(state.cal_display.toString()).match((/-?\d/g))
      console.log(state.cal_display, lastNumber)
  

      if(info['operation']=='+')
      {
        if(action.payload['koma']=='.'){
          state.result-=parseFloat(action.payload['lastNumber'])
        }
        console.log('sumdata')
        state.doing=1
        if(lastNumber.length>=3)
        {
          state.value=parseFloat(state.result);
          state.value += parseFloat(lastNumber[lastNumber.length-1]);
          console.log(state.value)
        }
        else{
          for(let i=0 ; i<lastNumber.length;i++)
          {
            state.value += parseFloat(lastNumber[i]);
          }
          console.log(state.value)
        }
      }
      else if(info['operation']=='-'){
        state.doing=1

        if(action.payload['koma']=='.'){
          state.result+=parseFloat(action.payload['lastNumber'])
        }
       
        state.value=parseFloat(state.result);
        state.value -= parseFloat(lastNumber[lastNumber.length-1]);
        state.result=state.value
       }
       else if(info['operation']=='/'){
        state.doing=1
        if(action.payload['koma']=='.'){
          state.result*=parseFloat(action.payload['lastNumber'])
        }
        state.value=parseFloat(state.result);
        state.value /= parseFloat(lastNumber[lastNumber.length-1]);
        state.result=state.value
       }
       else if(info['operation']=='x'){
        state.doing=1
        if(action.payload['koma']=='.'){
          state.result/=parseFloat(action.payload['lastNumber'])
        }
        state.value=parseFloat(state.result);
        state.value *= parseFloat(lastNumber[lastNumber.length-1]);
        state.result=state.value
        console.log(state.value)
       }
       lastInput=[lastNumber[lastNumber.length-1]]
      
       console.log(state.result)

    },
  
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  
});

export const { calculationByAmount,decrementByAmount,operation,reset } = counterSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectCount = (state) => state.counter.value;
export const cal_display = (state) => state.counter.cal_display;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.

export default counterSlice.reducer;
